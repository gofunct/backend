package grpc12factor

import (
	"github.com/go-pg/pg"
	"github.com/grpc-ecosystem/go-grpc-middleware"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"github.com/grpc-ecosystem/go-grpc-middleware/tags"
	"github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/heptiolabs/healthcheck"
	"github.com/opentracing/opentracing-go"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	jconfig "github.com/uber/jaeger-client-go/config"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"google.golang.org/grpc"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"log"
	"net"
	"net/http"
	"net/http/pprof"
	"time"
)

type Option func(*Runtime) *Runtime

func WithRootCmd() Option {
	return func(r *Runtime) *Runtime {
		r.RootCmd = &cobra.Command{
			Use:   "runtime",
			Short: "runtime is an golang engine to help power your grpc microservices",
		}
		return r
	}
}

func WithStore() Option {
	return func(r *Runtime) *Runtime {

		r.Store = pg.Connect(&pg.Options{
			User:                  viper.GetString("db_user"),
			Password:              viper.GetString("db_pass"),
			Database:              viper.GetString("db_name"),
			Addr:                  viper.GetString("db_host") + viper.GetString("db_port"),
			RetryStatementTimeout: true,
			MaxRetries:            4,
			MinRetryBackoff:       250 * time.Millisecond,
		})

		// Create Table from Todo struct generated by gRPC
		//db.CreateTable(&api.Todo{}, nil)
		return r
	}

}

func WithLogger() Option {
	return func(r *Runtime) *Runtime {
		var err error
		r.Log, err = zap.NewDevelopment()
		if err != nil {
			panic(err)
		}
		r.Log.With(
			zap.Bool("grpc_log", true),
			zap.String("grpc_port", viper.GetString("grpc_port")),
			zap.String("db_port", viper.GetString("db_port")),
			zap.String("db_name", viper.GetString("db_name")),
			zap.String("db_name", viper.GetString("db_user")),
		)

		zap.ReplaceGlobals(r.Log)
		r.Log.Debug("global logger successfully registered")
		return r
	}
}

func WithRouter() Option {
	check := healthcheck.NewMetricsHandler(prometheus.DefaultRegisterer, "runtime")

	return func(r *Runtime) *Runtime {

		r.Router = http.NewServeMux()
		r.Gate = runtime.NewServeMux()

		r.Router.HandleFunc("/swagger.json", func(w http.ResponseWriter, r *http.Request) {
			http.ServeFile(w, r, viper.GetString("swaggerfile"))
		})
		r.Log.Debug("swagger endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/swagger.json"))
		r.Router.Handle("/", r.Gate)
		r.Log.Debug("gateway endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/"))
		if viper.GetBool("live_endpoint") {
			check.AddLivenessCheck("goroutine_threshold", healthcheck.GoroutineCountCheck(viper.GetInt("routine_threshold")))
			r.Router.HandleFunc("/live", check.LiveEndpoint)
			r.Log.Debug("liveness endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/live"))
		}

		if viper.GetBool("ready_endpoint") {
			check.AddReadinessCheck("grpc_listener_health_check", healthcheck.TCPDialCheck(viper.GetString("grpc_port"), 1*time.Second))
			check.AddReadinessCheck("db_health_check", healthcheck.TCPDialCheck(viper.GetString("db_port"), 1*time.Second))
			r.Router.HandleFunc("/ready", check.ReadyEndpoint)
			r.Log.Debug("readiness endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/ready"))
		}
		if viper.GetBool("pprof_endpoint") {
			r.Router.Handle("/debug/pprof/", http.HandlerFunc(pprof.Index))
			r.Log.Debug("debug endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/debug/pprof"))
			r.Router.Handle("/debug/pprof/cmdline", http.HandlerFunc(pprof.Cmdline))
			r.Log.Debug("debug cmdline endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/debug/pprof/cmdline"))
			r.Router.Handle("/debug/pprof/profile", http.HandlerFunc(pprof.Profile))
			r.Log.Debug("debug profile endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/debug/pprof/profile"))
			r.Router.Handle("/debug/pprof/symbol", http.HandlerFunc(pprof.Symbol))
			r.Log.Debug("debug symbol endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/debug/pprof/symbol"))
			r.Router.Handle("/debug/pprof/trace", http.HandlerFunc(pprof.Trace))
			r.Log.Debug("debug trace endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/debug/pprof/trace"))
		}

		if viper.GetBool("metrics_endpoint") {
			r.Router.Handle("/metrics", promhttp.Handler())
			r.Log.Debug("metrics endpoint successfully registered:", zap.String("endpoint", viper.GetString("grpc_port")+"/metrics"))
		}

		r.Debug = &http.Server{
			Handler: r.Router,
		}

		return r
	}

}

func WithTracer() Option {
	return func(r *Runtime) *Runtime {
		var err error
		var tracer opentracing.Tracer
		cfg, err := jconfig.FromEnv()
		if err != nil {
			log.Fatal("failed to read jaeger config from environment")
		}
		cfg.ServiceName = "runtime"
		cfg.RPCMetrics = viper.GetBool("jaeger_metrics")

		tracer, r.Closer, err = cfg.NewTracer()
		if err != nil {
			log.Fatal("failed to create a new jager tracer")
		}
		opentracing.SetGlobalTracer(tracer)
		r.Log.Debug("global tracer successfully registered")

		return r
	}

}

func WithServer() Option {
	return func(r *Runtime) *Runtime {
		metrics := &MetricsIntercept{
			monitoring: initMonitoring(viper.GetBool("monitor_peers")),
			trackPeers: viper.GetBool("monitor_peers"),
		}
		grpc_zap.ReplaceGrpcLogger(zap.L())
		zopts := []grpc_zap.Option{
			grpc_zap.WithDurationField(func(duration time.Duration) zapcore.Field {
				return zap.Int64("grpc.time_ns", duration.Nanoseconds())
			}),
		}
		// Make sure that log statements internal to gRPC library are logged using the zapLogger as well.
		grpc_zap.ReplaceGrpcLogger(zap.L())
		s := grpc.NewServer(
			grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
				grpc_ctxtags.StreamServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
				grpc_opentracing.StreamServerInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer())),
				metrics.StreamServer(),
				grpc_zap.StreamServerInterceptor(zap.L(), zopts...),
			)),
			grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
				grpc_ctxtags.UnaryServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
				grpc_opentracing.UnaryServerInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer())),
				metrics.UnaryServer(),
				grpc_zap.UnaryServerInterceptor(zap.L(), zopts...),
			)),
		)

		grpc_health_v1.RegisterHealthServer(s, health.NewServer())
		r.Log.Debug("grpc healthcheck service successfully registered")
		RegisterMetricsIntercept(s, metrics)
		r.Server = s
		return r

	}
}

func WithDialer() Option {
	return func(r *Runtime) *Runtime {
		metrics := &MetricsIntercept{
			monitoring: initMonitoring(viper.GetBool("monitor_peers")),
			trackPeers: viper.GetBool("monitor_peers"),
		}
		opts := []grpc_zap.Option{
			grpc_zap.WithDurationField(func(duration time.Duration) zapcore.Field {
				return zap.Int64("grpc.time_ns", duration.Nanoseconds())
			}),
		}
		streamInterceptors := grpc.StreamClientInterceptor(grpc_middleware.ChainStreamClient(
			grpc_zap.StreamClientInterceptor(r.Log, opts...),
			grpc_opentracing.StreamClientInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer())),
			metrics.StreamClient(),
		))

		unaryInterceptors := grpc.UnaryClientInterceptor(grpc_middleware.ChainUnaryClient(
			grpc_zap.UnaryClientInterceptor(r.Log, opts...),
			grpc_opentracing.UnaryClientInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer())),
			metrics.UnaryClient(),
		))

		prometheus.DefaultRegisterer.Register(metrics)

		r.DialOpts = []grpc.DialOption{
			grpc.WithInsecure(),
			grpc.WithUnaryInterceptor(unaryInterceptors),
			grpc.WithStreamInterceptor(streamInterceptors),
			grpc.WithStatsHandler(metrics),
			grpc.WithDialer(metrics.Dialer(func(addr string, timeout time.Duration) (net.Conn, error) {
				return net.DialTimeout("tcp", addr, timeout)
			}))}
		return r
	}
}
