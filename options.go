package runtime

import (
	"github.com/go-pg/pg"
	"github.com/grpc-ecosystem/go-grpc-middleware"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"github.com/grpc-ecosystem/go-grpc-middleware/tags"
	"github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
	"github.com/heptiolabs/healthcheck"
	"github.com/opentracing/opentracing-go"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	jconfig "github.com/uber/jaeger-client-go/config"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"google.golang.org/grpc"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"log"
	"net/http"
	"net/http/pprof"
	"time"
)

type Option func(*Runtime) *Runtime

func WithRootCmd() Option {
	return func(r *Runtime) *Runtime {
		r.RootCmd = &cobra.Command{
			Use:   "runtime",
			Short: "runtime is an golang engine to help power your grpc microservices",
		}
		return r
	}
}

func WithStore() Option {
	return func(r *Runtime) *Runtime {

		r.Store = pg.Connect(&pg.Options{
			User:                  viper.GetString("db_user"),
			Password:              viper.GetString("db_pass"),
			Database:              viper.GetString("db_name"),
			Addr:                  viper.GetString("db_host") + viper.GetString("db_port"),
			RetryStatementTimeout: true,
			MaxRetries:            4,
			MinRetryBackoff:       250 * time.Millisecond,
		})

		// Create Table from Todo struct generated by gRPC
		//db.CreateTable(&api.Todo{}, nil)
		return r
	}

}

func WithLogger() Option {
	return func(r *Runtime) *Runtime {
		var err error
		r.Log, err = zap.NewDevelopment()
		if err != nil {
			panic(err)
		}
		r.Log.With(zap.Bool("grpc_log", true), zap.Any("config", viper.AllSettings()))
		return r
	}
}

func WithRouter() Option {
	check := healthcheck.NewMetricsHandler(prometheus.DefaultRegisterer, "runtime")

	return func(r *Runtime) *Runtime {
		check.AddLivenessCheck("goroutine_threshold_300", healthcheck.GoroutineCountCheck(300))
		check.AddReadinessCheck("grpc_listener_health_check", healthcheck.TCPDialCheck(viper.GetString("grpc_port"), 1*time.Second))
		check.AddReadinessCheck("db_health_check", healthcheck.TCPDialCheck(viper.GetString("db_port"), 1*time.Second))
		r.Router = http.NewServeMux()
		r.Router.HandleFunc("/live", check.LiveEndpoint)
		r.Log.Debug("liveness endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/live"))
		r.Router.HandleFunc("/ready", check.ReadyEndpoint)
		r.Log.Debug("readiness endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/ready"))
		r.Router.Handle("/metrics", promhttp.Handler())
		r.Log.Debug("metrics endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/metrics"))
		r.Router.Handle("/debug/pprof/", http.HandlerFunc(pprof.Index))
		r.Log.Debug("debug endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/debug/pprof"))
		r.Router.Handle("/debug/pprof/cmdline", http.HandlerFunc(pprof.Cmdline))
		r.Log.Debug("debug cmdline endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/debug/pprof/cmdline"))
		r.Router.Handle("/debug/pprof/profile", http.HandlerFunc(pprof.Profile))
		r.Log.Debug("debug profile endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/debug/pprof/profile"))
		r.Router.Handle("/debug/pprof/symbol", http.HandlerFunc(pprof.Symbol))
		r.Log.Debug("debug symbol endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/debug/pprof/symbol"))
		r.Router.Handle("/debug/pprof/trace", http.HandlerFunc(pprof.Trace))
		r.Log.Debug("debug trace endpoint registered:", zap.String("endpoint", viper.GetString("grpc_debug_port")+"/debug/pprof/trace"))
		return r
	}

}

func WithTracer() Option {
	return func(r *Runtime) *Runtime {
		var err error
		var tracer opentracing.Tracer
		cfg, err := jconfig.FromEnv()
		if err != nil {
			log.Fatal("failed to read jaeger config from environment")
		}
		cfg.ServiceName = "runtime"
		cfg.RPCMetrics = true

		tracer, r.Closer, err = cfg.NewTracer()
		if err != nil {
			log.Fatal("failed to create a new jager tracer")
		}
		opentracing.SetGlobalTracer(tracer)
		r.Log.Debug("global tracer successfully registered")

		return r
	}

}

func WithServer(peers bool) Option {
	return func(r *Runtime) *Runtime {
		r.Metrics = &MetricsIntercept{
			monitoring: initMonitoring(peers),
			trackPeers: peers,
		}
		grpc_zap.ReplaceGrpcLogger(zap.L())
		zopts := []grpc_zap.Option{
			grpc_zap.WithDurationField(func(duration time.Duration) zapcore.Field {
				return zap.Int64("grpc.time_ns", duration.Nanoseconds())
			}),
		}
		// Make sure that log statements internal to gRPC library are logged using the zapLogger as well.
		grpc_zap.ReplaceGrpcLogger(zap.L())
		s := grpc.NewServer(
			grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
				grpc_ctxtags.StreamServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
				grpc_opentracing.StreamServerInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer())),
				r.Metrics.StreamServer(),
				grpc_zap.StreamServerInterceptor(zap.L(), zopts...),
			)),
			grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
				grpc_ctxtags.UnaryServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
				grpc_opentracing.UnaryServerInterceptor(grpc_opentracing.WithTracer(opentracing.GlobalTracer())),
				r.Metrics.UnaryServer(),
				grpc_zap.UnaryServerInterceptor(zap.L(), zopts...),
			)),
		)

		grpc_health_v1.RegisterHealthServer(s, health.NewServer())
		RegisterMetricsIntercept(s, r.Metrics)
		r.Server = s
		return r

	}

}
